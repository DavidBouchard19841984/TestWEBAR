<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site 3D avec Vidéo 360°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            position: fixed;
            background-color: #000;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            color: white;
            font-size: 20px;
            z-index: 100;
            transition: opacity 0.5s;
        }
        #inner-video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">Chargement...</div>
    </div>

    <video id="inner-video" loop muted playsinline crossOrigin="anonymous">
        <!-- Remplacement par une vidéo 360° -->
        <source src="https://threejs.org/examples/textures/pano.webm" type="video/webm">
    </video>

    <canvas id="bg-canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');
        const video = document.getElementById('inner-video');

        // --- Gestionnaire de Chargement ---
        const loadingManager = new THREE.LoadingManager(
            () => {
                gsap.to(loadingScreen, { opacity: 0, duration: 1, onComplete: () => {
                    loadingScreen.style.display = 'none';
                }});
                // On lance l'expérience automatiquement
                startExperience();
            },
            (itemUrl, itemsLoaded, itemsTotal) => {
                loadingText.textContent = `Chargement ${Math.round((itemsLoaded / itemsTotal) * 100)}%`;
            },
            (url) => {
                console.error('Erreur de chargement pour :', url);
                loadingText.textContent = "Erreur de chargement. Veuillez rafraîchir la page.";
            }
        );

        // --- Initialisation de base ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#bg-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // --- Contrôles Orbitaux ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 25;
        controls.maxPolarAngle = Math.PI / 2 + 0.3;
        controls.minPolarAngle = Math.PI / 2 - 0.5;

        // --- Environnement et Fond ---
        const cubeTextureLoader = new THREE.CubeTextureLoader(loadingManager);
        const environmentMap = cubeTextureLoader.load([
            'https://threejs.org/examples/textures/cube/pisa/px.png', 'https://threejs.org/examples/textures/cube/pisa/nx.png',
            'https://threejs.org/examples/textures/cube/pisa/py.png', 'https://threejs.org/examples/textures/cube/pisa/ny.png',
            'https://threejs.org/examples/textures/cube/pisa/pz.png', 'https://threejs.org/examples/textures/cube/pisa/nz.png'
        ]);
        scene.background = environmentMap;
        scene.environment = environmentMap;

        // --- Lumières ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight.position.set(0, 0, 2); 
        camera.add(pointLight); 
        scene.add(camera);

        // --- Création du Texte 3D ---
        const fontLoader = new FontLoader(loadingManager);
        fontLoader.load(
            'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json',
            (font) => {
                const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.5 });
                const titleGeometry = new TextGeometry('Spheres Deformables', {
                    font: font, size: 0.5, height: 0.1, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.01, bevelOffset: 0, bevelSegments: 5
                });
                titleGeometry.center();
                const titleMesh = new THREE.Mesh(titleGeometry, textMaterial);
                titleMesh.position.set(0, 1.5, 0);
                scene.add(titleMesh);
            }
        );

        // --- Sphères Déformables ---
        const distortionUniforms = { uTime: { value: 0 }, uSpeed: { value: 0.2 }, uStrength: { value: 0.1 } };
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            metalness: 0, roughness: 0.1, transmission: 1.0, thickness: 5, ior: 5, transparent: true
        });

        glassMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = distortionUniforms.uTime;
            shader.uniforms.uSpeed = distortionUniforms.uSpeed;
            shader.uniforms.uStrength = distortionUniforms.uStrength;
            shader.vertexShader = shader.vertexShader.replace('void main() {', `uniform float uTime; uniform float uSpeed; uniform float uStrength; vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; } float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0) ; const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i  = floor(v + dot(v, C.yyy) ); vec3 x0 =   v - i + dot(i, C.xxx) ; vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min( g.xyz, l.zxy ); vec3 i2 = max( g.xyz, l.zxy ); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 )); float n_ = 0.142857142857; vec3  ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw ); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ; vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) ); } void main() {`);
            shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `#include <begin_vertex>\nfloat distortion = snoise(position + uTime * uSpeed) * uStrength;\ntransformed += normalize(position) * distortion;`);
        };

        const innerMaterial1 = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const innerMaterial2 = new THREE.MeshBasicMaterial({ color: 0x000000 });

        const outerGeometry = new THREE.SphereGeometry(2, 128, 128);
        const innerGeometry = new THREE.SphereGeometry(1.5, 128, 128);

        const group1 = new THREE.Group();
        const glassSphere1 = new THREE.Mesh(outerGeometry, glassMaterial);
        group1.add(glassSphere1, new THREE.Mesh(innerGeometry, innerMaterial1));
        group1.position.set(-5, 4, -5);
        scene.add(group1);

        const group2 = new THREE.Group();
        const glassSphere2 = new THREE.Mesh(outerGeometry, glassMaterial);
        group2.add(glassSphere2, new THREE.Mesh(innerGeometry, innerMaterial2));
        group2.position.set(5, 4, -5);
        scene.add(group2);
        
        // --- Démarrage de l'expérience ---
        function startExperience() {
            console.log("Tentative de lancement automatique de la vidéo.");
            video.play().then(() => {
                console.log("SUCCÈS : La vidéo a démarré ! Application de la texture.");
                const videoTexture = new THREE.VideoTexture(video);
                
                innerMaterial1.color.set(0xffffff); 
                innerMaterial1.map = videoTexture;
                innerMaterial1.needsUpdate = true;
                
                innerMaterial2.color.set(0xffffff);
                innerMaterial2.map = videoTexture;
                innerMaterial2.needsUpdate = true;

            }).catch(e => {
                console.error("ERREUR : La lecture de la vidéo a été bloquée par le navigateur.", e);
            });
            
            animate();
        }

        // --- Gestion du redimensionnement ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Boucle d'animation ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            distortionUniforms.uTime.value = elapsedTime;

            // Animation de flottement relative à la nouvelle position
            group1.position.y = 4 + Math.sin(elapsedTime * 0.5) * 0.5;
            group1.rotation.y += 0.002;
            group2.position.y = 4 + Math.cos(elapsedTime * 0.4) * 0.6;
            group2.rotation.y -= 0.002;

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
